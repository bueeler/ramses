//  -------------------------------------------------------------------------
//  Copyright (C) 2016 BMW Car IT GmbH
//  -------------------------------------------------------------------------
//  This Source Code Form is subject to the terms of the Mozilla Public
//  License, v. 2.0. If a copy of the MPL was not distributed with this
//  file, You can obtain one at https://mozilla.org/MPL/2.0/.
//  -------------------------------------------------------------------------

/**
@page RendererAPI RAMSES Renderer API

The RAMSES Renderer API allows to
* setup the rendering infrastructure
* control the graphical content, which is to be displayed
* render the content to be displayed
* access/control to the system compositor controller

# Setup rendering infrastructure

The renderer setup consists of a RamsesRenderer object and a set of displays belonging to it.
Every display can be configured through an individual display configuration, described below.

## Display configuration options
- Display Size
- Viewport settings
- Camera parameters
- Stereo rendering support
- Warping support
- Multi-sampling

# Display Graphical Content

## Scene States
In order to show graphical content (i.e. scenes created by RAMSES clients) on a certain display, the renderer has to
-# check if the scene is published
-# subscribe to the scene
-# map the scene to a display
-# show the scene

@image html renderer_scene_states.png "Renderer Scene States"

<b>Important:</b>
- Resource handling as described in the state descriptions of the state diagram above is not yet implemented.
- A scene can only be "mapped" to ONE display of a renderer at the same time.

## Data Linking

In order to achieve scene interaction, it is possible to attach scene content of one scene to scene content of another scene. There are several types of data links,
all of them have a data provider on one side and one or more consumers on the other side, the consumers then use the data of the provider.

Provider and consumer data is tagged with an ID on RAMSES client scene side and then can be linked on RAMSES renderer side. Scenes with provider and consumer data can come
from different clients that do not have to know each other (only the tagged data IDs are globally known) and once the scenes are subscribed (mapped in case of texture linking)
on renderer they can be linked together.

Data links are dynamic so any change to provider data (including animations) will be reflected to all its consumers.

### Transformation Linking

For transformation data linking the provided scene content is the transformation matrix of a scenegraph node (any Node typed object in scene), which can be consumed by Node(s) of consumer scene(s).
The consumer node (and all its children in scenegraph topology) will transform using the provider node's transformation.

### DataObject Linking

DataObjects can be used to set values to Appearance's uniforms or Camera parameters and these can be linked as well across scenes. As long as data type is matched a data value stored in a DataObject of one scene
can be used as uniform input of an Appearance in another scene.

### Texture Linking

Texture resources can be tagged as data providers and can be consumed in another scene by TextureSampler. In order to be able to successfully link textures both the provider and consumer scenes
have to be mapped to the same display as they are going to share a GPU resource.

# Renderer API calls & Events

Renderer API calls are handled asynchronously. This means that the result or information about success of the requested renderer operation is not available
immediately after the API call.
The result of the API call will be delivered via renderer events. The RAMSES renderer offers an event dispatching mechanism, such that an object implementing
the ramses::IRendererEventHandler interface can handle and process renderer events.

There are callbacks for the following events:
- display created/destroyed
- scene un/published
- scene un/subscribed
- scene un/mapped
- scene shown/hidden
- data un/linked
- data provider/consumer created/destroyed
- framebuffer-pixel read

Check ramses::IRendererEventHandler for the full list of events and corresponding callbacks.

Events generated as a result of a Renderer API call will have a result parameter stating whether:
- [OK] the Renderer API call was successful
- [FAIL] the Renderer API call was unsuccessful
- [INDIRECT] the event was implicitly generated by another Renderer API call/Event or a scene state change caused by a RAMSES client

## Renderer API transactions

The RAMSES Renderer only executes committed Renderer API calls. To commit a transaction of Renderer API calls, call ramses::RamsesRenderer::flush().<br>
All Renderer API calls since the last flush will then be executed on the next ramses::RamsesRenderer::doOneLoop() function call or when there is new frame processed if using render thread.

*/
